( /* ГИТ 1 - МАНЧЕНКОВ А./ СИМДЯНОВ И./ КРОТОВ И.
==============================================================================================================*/

( /* УРОК 2. УСТАНОВКА И НАСТРОЙКА ТЕРМИНАЛА
--------------------------------------------------------------------------------------------------------------*/ 
https://git-scm.com/

git --version /// версия git


git update  /// обновить гит


git config --global user.name 'name'  /// регистрация логина пользователя
git config --global user.email 'email'  /// регистрация почты пользователя
git config --global color.ui auto  /// включает подсветку в терминале
git config --global core.editor vi  /// установка редактора vim по умолчанию
git config --global core.editor nano  /// установка редактора nano по умолчанию


git config --list  /// посмотреть список конфигураций
git config --list --show-origin  /// показать местонахождения файла с настройками git

alias gg="git log --pretty=oneline"  /// создать короткий псевдоним(алиас) "gg", для команды вывода коммитов в одну строку, с показом полного хеша
)

( /* УРОК 3. КОМАНДЫ - БАЗОВЫЕ ОПЕРАЦИИ В КОМАНДНОЙ СТОКЕ/ ТЕРМИНАЛЕ
--------------------------------------------------------------------------------------------------------------*/ 
cd  /// переход в папку(директорию)
cd TestDir

~  /// точка начала пути (обозначает что вы находитесь в домашней директории(папке))

cd ~  /// быстрый переход в папку пользователя

cd ..  /// подняться(выйти из папки) на один уровень выше

cd ../..  /// подняться на два уроня

mkdir  /// создать папку(директорию)
mkdir TestDir

touch  /// создать файл
touch test.txt

touch <directory>/<file>  /// создать файл в директории
touch TestDir/test.txt

cp  /// копировать файл
cp test.txt test_copy.txt  /// копировать файл test.txt в файл test_copy.txt

echo  /// вывести запись в терминал
echo 'updated'  /// выведет "updated" в терминале
echo 'updated' > fail.md  /// перезаписать содержимое fail.md/ создать "fail.md" и записать в него "updated"
echo '123' >> fail.md  /// дописать строку "123" в конец файла "fail.md"

mv  /// переименовать/ переместить файл/ папку
mv test.txt test_original.txt  /// переименовать файл test.txt в test_original.txt
mv test.txt dir1  /// переместить test.txt в dir1 

rm  /// удаление файлов, безвозвратно
rm test_original.txt  /// удалить файл test_original.txt

rm -R  /// удаление папки
rm -R TestDir  /// удалить папку TestDir
sudo rm -R TestDir  /// удалить папку TestDir от имени администратора

cat  /// просмотр содержимого файла
cat test_original.txt  /// просмотр содержимого файла test_original.txt

ls  /// посмотреть список файлов
ls -a  /// расширенный просмотр содержимого папки
ls -l  /// просмотр всех файлов таблицей
ls -l -a .*  /// просмотр таблицей всех скрытых файлов, имя которых начинается с точки
ls -l file*  /// просмотр всех файлов в начале имени которых присутствует "file

clear  /// очистить терминал
)

( /* УРОК 4. СКАЧИВАНИЕ УДАЛЕННОГО РЕПОЗИТОРИЯ (АВТОМАТИЧЕСКАЯ НАСТРОЙКА remote ЧЕРЕЗ "clone"); HTTPS; SSH
--------------------------------------------------------------------------------------------------------------
НА Github:
1.  КОПИРУЕМ https ССЫЛКУ
В ТЕРМИНАЛЕ:
2.  mkdir <direct_name>  /// создать пустую локальную директорию

3.  git clone <https>  /// remote соединение создастся автоматически

4.  И В ЭТОЙ ПАПКЕ ПОЯВИТСЯ ЕЩЕ ОДНА ПАПКА С РАПОЗИТОРИЕМ ИЗ Github

5.  ПЕРЕОТКРЫТЬ VS CODE УЖЕ ИЗ ПАПКИ СКАЧЕННОГО РЕПОЗИТОРИЯ

6.  git remote -v  /// проверка списка подключенных репозиториев (должно быть два)

7.  ВНОСИМ ИЗМЕНЕНИЯ

8.  ЗАКОМИТИТЬ

9.  git push origin <branch_name>  /// залить ветку branch_name обратно на удаленный репозиторий, при необходимости связать git и Github */


git remote  /// имена доступных remote соединений (должен показать "origin")

cat ~/Desktop/file/.git/config  /// запись "[remote "origin"]", в файле "config" говорит об успешном remote подключении
vi config  /// ручное редактирование файла "config", через редактор "vi"


/* HTTPS
СКАЧАТЬ ЧУЖОЙ РЕПОЗИТОРИЙ С Github ЧЕРЕЗ "https" (БЕЗ АВТОРИЗАЦИИ И ВОЗМОЖНОСТИ ПУБЛИКАЦИИ ИЗМЕНЕНИЙ)
1. ЗЕЛЕНАЯ КНОПКА "Code" -> https -> копировать
В ТЕРМИНАЛЕ:
2. git clone <https>  /// скачать репозиторий по ссылке в текущую локальную папку


   SSH (НАСТРОЙКА)
СКАЧАТЬ ЧУЖОЙ РЕПОЗИТОРИЙ С Github ЧЕРЕЗ "ssh" (БЕЗ АВТОРИЗАЦИИ И ВОЗМОЖНОСТИ ПУБЛИКАЦИИ ИЗМЕНЕНИЙ)
В ТЕРМИНАЛЕ:
1. ssh-keygen  /// сгенерировать ssh ключ
   Enter -> Enter -> Enter
НА Github:
2. Profile -> Settings -> SSH and GPG keys -> New ssh key -> ВСТАВИТЬ КЛЮЧ
3. ПЕРЕЙТИ В НУЖНЫЙ РЕПОЗИТОРИЙ -> ЗЕЛЕНАЯ КНОПКА "Code" -> ssh -> КОПИРОВАТЬ
4. git clone <ssh>  /// скачать репозиторий по ssh в текущую локальную папку */
)

( /* УРОК 5. КОММИТЫ - УПРАВЛЕНИЕ ФАЙЛАМИ РЕПОЗИТОРИЯ
--------------------------------------------------------------------------------------------------------------*/ 
/// КОММИТ - ЗАПИСЬ С ОПИСАНИЕМ ИЗМЕНЕНИЯ

pwd  /// текущее положение файла

git add  /// добавление одного файла в индекс
git add <file>

git add .  /// добавление всех файлов в индекс

git commit  /// записать коммит через редактор vi
i  /// для начала записи в коммит
esc :wq  /// выход из режима записи коммита -> w(запись изменений)/ q(выход)/ Enter

git commit -m '..'  /// сохранение состояния текущих файлов

git commit -am '..'  /// добавление файла в индекс с записью коммита

unlink <file>  /// удаление неиндексированного файла

git rm --cached  /// удаление файла из индекса
git rm --cached <file>

git checkout -- <file>  /// откатить файл к последнему коммиту

git reset HEAD <file>  /// перевод файла из индекса, в неиндексированное состояние

git status  /// статус текущего репозитория
// ОСНОВНЫЕ СОСТОЯНИЯ ФАЙЛОВ В ГИТ:
untracted  /// неотслеживаемый файл
added  /// файл добавлен для отслеживания, но не был изменен
modified  /// файл добавлен для отслеживания и изменен
deleted  /// отслеживаемый файл был удален
если файл в vs code подсвечен белым, без буквы - значит гит его отслеживает и файл не изменялся*

git status -s  /// статус в сокращенном виде

git diff  /// вывести изменения из неотслеживаемых файлов, еще недобавленных в индекс

it diff master  /// вывести все сделанные изменения в файлах ветки "master"

git diff --cached  /// несколько изменений файлов в одном коммите, посмотреть какие изменения будут внесены в каждый из файлов
+зеленые строки  /// добавленные строки
-красные строки  /// удаленные строки

git show <hash>  /// посмотреть описание текущего коммита

git show HEAD  /// посмотреть описание последнего коммита
git show HEAD~1  /// посмотреть описание предпоследнего коммита

.gitkeep  /// файл для отображения пустых папок/ файлов в репозитории
touch <directory>/.gitkeep  /// создать файл ".gitkeep" в пустой папке "directory" для ее отображения и записи коммита в репозиторий

.ignore  /// файл для непопадания папок/ файлов в репозиторий
touch .gitignore  /// создание файла ".gitignore"
echo 'file' > .gitignore  /// игнорировать "file"
touch file  /// создания самого файла "file", который будет игнорироваться

echo '*.log' > .gitignore  /// игнорировать все файлы с расширением "log"
echo 'tmp/*' > .gitignore  /// игнорировать все файлы в папке "tmp"
)

( /* УРОК 6. ИСТОРИЯ РЕПОЗИТОРИЯ - ПРОСМОТР ВЕРСИЙ ПРОЕКТА
--------------------------------------------------------------------------------------------------------------*/ 
git log  /// показать историю коммитов с метаинформацией, на текущей ветке
space  /// листать дальше
q  /// выход из режима просмотра коммитов

git log -2  /// показать два последних коммита
git log -p  /// показать историю коммитов, и что именно менялось в каждом коммите
git log --stat  /// под каждым из коммитов выводится список измененных файлов, и сколько строк было + или -
git log --pretty=oneline  /// сокращенный вывод коммитов в одну строку, с показом полного хеша
git log --oneline  /// история коммитов в сокращенном виде, с сокращенным хешем
git log --oneline --all  /// история всех коммитов на всех ветках

git log --graph  /// история всех коммитов с визуализацией в графах

git reflog  /// показать историю всех действий в репозитории

git log --since=2.week  /// поиск всех коммитов за последние 2 недели
git log --until=1.week  /// поиск всех коммитов, кроме коммитов, сделанных за последнюю неделю
git log --since=2022-03-01 --until=2022-03-25  /// поиск всех коммитов с 1 по 25 марта 2022года

git log -SGit -p  /// найти все коммиты, в которых упоминается слово "Git"
git log --author='name'  /// найти все коммиты конкретного разработчика
git blame file.txt  /// выяснить автора и время изменения коммита для файла "file.txt" (1385c228 (axel_win 2022-06-11 16:41:02 +0300 1) 321)

git reset <hash>  /// откат состояния файла на конкретный коммит

git reset --hard <hash>  /// откат состояния репозитория на конкретный коммит
git reset --hard  /// откат состояния репозитория на последний коммит

git revert <hash>  /// отменить действие при котором был записан конкретный коммит
 
git restore <file>  /// сброс состояния файла на состояние последнего коммита

git checkout master  /// вернуться на актуальное состояние файла (после переключений "git log")
)

( /* УРОК 7. ВЕТКИ - МАНИПУЛЯЦИИ И ПРИНЦИП РАБОТЫ
--------------------------------------------------------------------------------------------------------------*/ 
/* ВЕТКА - ХРОНОЛОГИЧЕСКАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ КОММИТОВ
           ЭТО ГРУППИРОВКА КОММИТОВ, И КОГДА МЫ ВВОДИМ:  
git checkout <branch_name> - МЫ ПЕРЕХОДИМ К ДРУГОЙ ГРУППЕРОВКЕ КОММИТОВ  
git merge <branch_name> - ОБЪЕДИНЯЕМ КОММИТЫ */
!!!КОММИТЫ БУДУТ ЗАПИСЫВАТЬСЯ В ТОЛЬКО В ТЕКУЩУЮ ВЕТКУ, ИГНОРИРУЯ ОСТАЛЬНЫЕ

git branch  /// посмотреть локальные ветки

git branch -r  /// посмотреть удаленные ветки

git branch --all   /// посмотреть локальные и удаленные ветки

git branch <branch_name>  /// создать новую ветку "branch_name" (для этого на основной ветке должен быть хотя бы один коммит!)

git checkout <branch_name>  /// переключиться на ветку "branch_name"

git branch <branch1> <branch2>  /// создать ветку "branch1", основой для которой будет ветка "branch2"

git checkout -b <branch1>  /// одновременное создание(если таковой ветки еще нет) ветки "branch1" и переключение на нее, за основу будет взята текущая ветка
git checkout -b <branch1> <branch2>  /// одновременное создание(если таковой ветки еще нет) ветки "branch1" и переключение на нее, за основу будет взята ветка "branch2"

git branch -m dev dev2  /// переименовать локальную ветку "dev" в "dev2"

git branch -d <branch_1> <branch_2>  /// удалить локальную/ые ветку/и
ИЛИ
git branch -D <branch_name>  /// принудительно удалить локальную ветку branch_name

git push --delete origin <branch_1> <branch_2>  /// удалить удаленные ветки "branch_1" и "branch_2"
ИЛИ
git push origin :<branch_1> <branch_2>

git pull origin <branch_name>  /// скачать удаленную ветку (чтобы отображалась нужно на нее перейти)


/// ПЕРЕИМЕНОВАТЬ УДАЛЕННУЮ ВЕТКУ "dev" В "dev2" В УДАЛЕННОМ РЕПОЗИТОРИИ:
1. git branch dev2 origin/dev  /// создать локальную ветку dev2, которая является копией удаленной ветки dev
2. git push origin dev2  /// загружаем ее в удаленный репозиторий
3. git push origin :dev  /// удаляем ненужную удаленную ветку "dev"
)

( /* УРОК 8. ПУБЛИКАЦИЯ ЛОКАЛЬНОГО РЕПОЗИТОРИЯ (РУЧНАЯ НАСТРОЙКА remote ЧЕРЕЗ "git remote add")
--------------------------------------------------------------------------------------------------------------
НА Github:
1.  СОЗДАТЬ НОВЫЙ, ПУСТОЙ, ПУБЛИЧНЫЙ РЕПОЗИТОРИЙ (БЕЗ readme, .gitignore И licence)
В ТЕРМИНАЛЕ:
2.  git init  /// создание локального репозитория в нужной локальной папке

3.  touch readme  /// создать файл readme с описанием репозитория

4.  git commit -am 'first commit'  /// закомитить

5.  git branch -M main  /// переименовать текущую ветку в "main" (не обязательно, если хотим чтобы на Github основная ветка тоже была "master")

6.  git remote add origin <https>  /// создать remote соединение 

7.  git remote -v  /// проверка списка подключенных репозиториев (должно быть два)

8.  git push -u origin <branch_name>  /// установить push по умолчанию, из текущей ветки, именно в удаленную ветку "branch_name" и загрузить туда все локальные изменения, для дальнейшей сокрашенной комманды "git push" (создаст удаленную ветку "branch_name" если ее еще нет в удаленном репозитории; переназначить push: git push -u origin <new_branch_name>)
НА Github:
9.  ВНЕСТИ ИЗМЕНЕНИЯ С ДРУГОГО ЛОКАЛЬНОГО КОМПЬЮТЕРА ИЛИ НА Github (иконка "карандаш")

10. ЗАКОМИТИТЬ  /// в самом низу "Commit changes"
В ТЕРМИНАЛЕ:
11. git pull  /// подгрузить изменения с удаленного репозитория на локальный компьютер */

git push origin <branch_name>  /// загрузить локальные изменения из ветки branch_name в удаленную ветку

git push origin --all  /// загрузить все ветки в удаленный репозиторий (!!!не рекомендуется так делать)

git fetch  /// обновить версию репозитория с удаленного сервера
)

( /* УРОК 9. СЛИЯНИЯ - ОПЕРАЦИИ ОБЪЕДИНЕНИЯ, УДАЛЕНИЯ И СМЕЩЕНИЯ ВЕТОК
--------------------------------------------------------------------------------------------------------------*/
git merge <branch_name>  /// влить изменения из branch_name в текущую ветку 

git merge dev1 dev2  /// локально влить в текущую ветку, все изменения из веток dev1 и dev2

git merge --abort  /// отменить слияние

git rebase main  /// переключить начало текущей ветки на последний коммит ветки 'main'

git push --force  /// перезаписать историю в удаленном репозитории, после rebase
)

( /* УРОК 10. ВЕРСИОНИРОВАНИЕ - УПРАВЛЕНИЕ ТЕГАМИ ПРОЕКТА
--------------------------------------------------------------------------------------------------------------*/
/* ТЕГ - ВЕРСИЯ ПРОЕКТА
       - ССЫЛКА НА КОММИТ(КОТОРЫЙ МОЖЕТ СОДЕРЖАТЬ НЕСКОЛЬКО ТЕГОВ)
	   - АНАЛОГ ХЕША, НО С БОЛЕЕ УДОБНЫМ ОБОЗНАЧЕНИЕМ */

1.2.0  /// 1(мажорная цифра); 2(минорная цифра); 0(патч-версия)

git tag <nomber>  /// присвоить последнему коммиту номер тега
git tag v1.0.0

git tag -a v1.0.0 -m 'Новый тег'  /// присвоить последнему коммиту номер тега и название "Новый тег"

git tag -a v0.0.0 -m 'Старый тег' 46f92d5  /// присвоить коммиту с хешем "46f92d5", номер тега и название "Старый тег"

git tag  /// посмотреть список тегов

git tag --list  /// посмотреть список остальных доступных версий

git tag -l v1.4*  /// поиск тега по шаблону(начинается с "v1.4" и дальше любое количество символов)

git show v.1.4.0  /// посмотреть описание текущего тега

git checkout -b <branch_name> <tag>/ <hash>  /// отпочковать ветку от определенного коммита/ тега
git checkout -b old_version_of_project v1.2.0
git checkout -b old_version_of_project 46f92d5

git push --tags  /// загрузить все теги на удаленный репозиторий
git push origin v1.2.0  /// загрузить определенный тег на удаленный репозиторий

git ls-remote --tags  /// запросить список тегов на удаленном репозитории

git tag -d <nomber>  /// удалить локальный тег

git push --delete origin v1.0.1  /// удалить удаленный тег v1.0.1

/// ЧТОБЫ ПЕРЕПИСАТЬ РАНЕЕ ЗАПИСАННЫЙ, ОШИБОЧНЫЙ ТЕГ, НА ПОСЛЕДНИЙ КОММИТ - НУЖНО:
1. УДАЛИТЬ УЖЕ СУЩЕСТВУЮЩИЙ ТЕГ (git tag -d <nomber>)
2. ПРИСВОИТЬ НОВЫЙ ГЕТ ПОСЛЕДНЕМУ КОММИТУ(git tag <nomber>)
)

( /* УРОК 11. Fork; pull-request
--------------------------------------------------------------------------------------------------------------*/
/* Fork - ПЕРСОНАЛЬНАЯ КОПИЯ ЧУЖОГО РЕПОЗИТОРИЯ НА СВОЙ АККАУНТ Github (ДЛЯ СОУЧАСТИЯ В РАЗРАБОТКЕ open-sourse ПРОЕКТА)
open-sourse  /// копия проекта с открытым исходным кодом, находящаяся в свободном доступе, доступная для скачивания в виде Fork-a
1.  КНОПКА "Fork" В ЧЬЕМ-НИБУДЬ РЕПОЗИТОРИИ -> "Create fork"  /// клонирование репозитория на свой аккаунт Github
В ТЕРМИНАЛЕ:
2.  git clone <https>  /// скачать репозиторий по ссылке в текущую локальную папку

3.  git branch <branch_name>  /// создание отдельной ветки, в которой будет вестись моя разработка и переход на нее

4.  СОЗДАТЬ ФАЙЛ readme.md (капс) С ОПИСАНИЕМ ТОГО ЧТО БУДЕТ ДЕЛАТЬСЯ

5.  ЗАКОМИТИТЬ

6.  ВНЕСТИ ИЗМЕНЕНИЯ

7.  ЗАКОМИТИТЬ

8.  git push -u origin <branch_name>  /// установить push по умолчанию, из текущей ветки, именно в удаленную ветку "branch_name" и загрузить туда все локальные изменения, для дальнейшей сокрашенной комманды "git push" (создаст удаленную ветку "branch_name" если ее еще нет в удаленном репозитории; переназначить push: git push -u origin <new_branch_name>)

9. СОЗДАНИЕ pull-request */


// pull-request
master   O -> O -> O -> O -> O -> O -> O -> O -> O -> O -> O -> O -> O -> O -> O
                   |                                                 ^
                   v                                                 | merge
                   |                                                 ^
                   v                                                 |
             dev   O -> O -> O -> O -> O -> O -> O -> O -> O -> O/* p/r */

/* PULL-REQUEST - ЗАПРОС(НА СЛИЯНИЕ), ПЕРЕД САМИМ СЛИЯНИЕМ
1. ПЕРЕХОДИМ НА Github, В ЭТОТ РЕПОЗИТОРИЙ НА СВОЕМ АККАУНТЕ, В ВЕТКУ С ИЗМЕНЕНИЯМИ

2. НАЖИМАЕМ КНОПКУ "pull-request" -> "new pull-request"

3. В ПРАВОЙ ЧАСТИ ВЫБИРАЕМ НАШУ ВЕТКУ ДЛЯ БУДУЩЕГО merge В master ВЕТКУ

4. "Create pull-request"

5. СОЗДАТЬ КОММИТ С ОПИСАНИЕМ

6. "Create pull-request" */

/// НУЖЕН ДЛЯ:
-ОБСУЖДЕНИЯ КОДА С КОЛЛЕГАМИ
-ВОЗМОЖНОСТЬ КОММЕНТИРОВАТЬ/ЛАЙКАТЬ КОД
-code-review (КОММЕНТАРИИ В САМОМ КОДЕ)
-ВОЗМОЖНОСТЬ ТЕСТИРОВАНИЯ ПЕРЕД merge
"!!!ЕСЛИ НАШИ ИЗМЕНЕНИЯ БУДУТ ЗАГРУЖЕНЫ В ОРИГИНАЛЬНЫЙ РЕПОЗИТОРИЙ, ТО ЕГО ВЛАДЕЛЕЦ СМОЖЕТ ПРИНЯТЬ/ ОТМЕНИТЬ/ ПРОКОМЕНТИРОВАТЬ НАШ pull request)"
)

( /* УРОК 12. СЛОЖНЫЕ ОПЕРАЦИИ - ПЕРЕКЛЮЧЕНИЕ ВЕТОК ПРИ НЕЗАПИСАННЫХ КОММИТАХ;
                               - ОБЪЕДИНЕНИЕ КОММИТОВ;
							   - ПЕРЕНОС КОНКРЕТНОГО КОММИТА НА ДРУГУЮ ВЕТКУ;
							   - ПЕРЕЗАПИСЬ КОММИТОВ БЕЗ ИЗМЕНЕНИЯ ИСТОРИИ;
							   - КОНФЛИКТЫ ПРИ ОБЪЕДИНЕНИИ ВЕТОК(ПРИ ПАРАЛЛЕЛЬНОЙ РАБОТЕ)
							     ПРИ ПОДГРУЗКЕ ДАННЫХ ИЗ УДАЛЕННЫХ РЕПОЗИТОРИЕВ.
--------------------------------------------------------------------------------------------------------------*/
/// ПЕРЕКЛЮЧЕНИЕ ВЕТОК ПРИ НЕЗАПИСАННЫХ КОММИТАХ
git stash  /// команда временного, локального сохранения файла(стеш), без записи коммита

git stash list  /// список стешей

git stash push <file>  /// добавить файл в уже существующий стеш, на текущей ветке
git stash push new-feature.go

git stash pop <stash>  /// развернуть стеш из списка
git stash pop stash@{0}  /// развернуть определенный стеш

git stash apply  /// вернуть состояние последнего файла из стеша, сам стеш сохраниться в стеш-списке
git stash apply stash@{1}  /// вернуть состояние кокретного файла из стеша, сам стеш сохраниться в стеш-списке

git stash drop  /// удалить последний стеш из списка и отменить изменения в файле 


/// ОБЪЕДИНЕНИЕ КОММИТОВ В ОДИН, ДЛЯ ПОСЛЕДУЮЩЕГО ЕГО ПЕРЕНОСА НА ДРУГУЮ ВЕТКУ(ЧТОБЫ НЕ ПЕРЕНОСИТЬ КОММИТЫ ПО ОТДЕЛЬНОСТИ)
git merge <branch_name> --squash  /// находясь на ветке "master", объединить все коммиты на ветке "branch", но без записи коммита

git rebase -i HEAD~3  /// переключить начало текущей ветки на 3 коммита назад, через режима редактирования (-i)
HEAD  /// наше текущее положение

git push --set-upstream origin <branch_name>  /// принудительная перезапись локально-объединенных коммитов, в удаленный репозиторий
ИЛИ
git push origin feature --force


/// ПЕРЕНОС КОНКРЕТНОГО КОММИТА НА ДРУГУЮ ВЕТКУ
git cherry-pick <hash commit>  /// перенести один коммит на текущую ветку
git cherry-pick 1f63f8c

git cherry-pick <branch_name>  /// перенести последний коммит из ветки "branch", на текущую ветку

git cherry-pick ..<branch_name>  /// перенести все коммиты из ветки "branch", на текущую ветку


git cherry -v master  /// вывести коммиты, которые отличают текущую ветку от ветки "master"


/// ПЕРЕЗАПИСЬ КОММИТОВ БЕЗ ИЗМЕНЕНИЯ ИСТОРИИ
git commit --amend  /// после внесения изменений и добавления файла в индекс(git add .), перезаписать последний коммит, через режима редактирования


/// КОНФЛИКТЫ ПРИ СЛИЯНИИ ВЕТОК, С ОДИНАКОВЫМИ ФАЙЛАМИ
1. vi <file>  /// открыть файл через текстовый редактор "vi", для ручного редактирования слияния
   <<<<<<<<  
   >>>>>>>>  /// обозначения конфликтов
   ========  /// резделитель конфликтов

2. РЕДАКТИРОВАНИЕ С ОСТАВЛЕНИЕМ ТОЛЬКО САМОГО ТЕКСТА КОММИТА, ВСЕ ОБОЗНАЧЕНИЯ УДАЛЯЮТСЯ

3. ПОСЛЕ ЧЕГО ДОБАВИТЬ ФАЙЛ В ИНДЕКС И ЗАКОМИТИТЬ
)

( /* ЯЗЫК РАЗМЕТКИ "Markdown" ДЛЯ GIT (формат .md)
==============================================================================================================*/
# ЗАГОЛОВОК ПЕРВОГО УРОВНЯ С ЛИНИЕЙ ОТСЕЧКИ  
## ЗАГОЛОВОК ВТОРОГО УРОВНЯ  
### ЗАГОЛОВОК ТРЕТЬЕГО УРОВНЯ
---  /// линия отсечки 

### ВЫДЕЛЕНИЕ ТЕКСТА:

*курсив* или _курсив_

**полужирный** или __полужирный__

__*курсив + полужирный*__

~~зачеркнутый~~

<u>подчеркнутый</u>

### ИЗОБРАЖЕНИЯ:

![альтернативный текст](Berries-raspberry-leaf_1920x1200.jpg)  //если картинка в тойже папке что и md файл

### ССЫЛКИ:

<https://axelfoley.ru>  /// ссылка на axelfoley.ru

[текст](ссылка)  /// ссылка из текста без подсказки

[текст](ссылка "подсказка")  /// ссылка из текста с подсказкой

### ТАБЛИЦЫ:

|Колонка 1|Колонка 2|Колонка 3|
|-|-|-|
|ЗАПИСЬ 1|ДЛИННАЯ ЗАПИСЬ 2|ЗАПИСЬ 3|
|ЗАПИСЬ 1| |ЗАПИСЬ 3
---
##### ВЫРАВНИВАНИЕ В ТАБЛИЦЕ:

|Колонка 1|Колонка 2|Колонка 3|
|:-|:-:|-:|
|Равнение по левому краю|Равнение по центру|Равнение по правому краю|
---

### ЦИТАТЫ:

> цитата

нецитатный текст

> ЦИТАТА
> > вложенная цитата
> > > вторая вложенная цитата

### СПИСКИ:
##### НУМЕРОВАННЫЙ СПИСОК
* элемент 1
* элемент 2
* элемент 3  
или  
+ элемент 4
+ элемент 5
---
##### НЕНУМЕРОВАННЫЙ СПИСОК
1. Первый элемент
2. Второй элемент
2. Второй элемент  
3. Третий элемент
---
##### ВЛОЖЕННЫЙ СПИСОК
1. Первый элемент
   1. первый подпункт 
   2. второй подпункт
2. Второй элемент
   1. первый подпункт
)
